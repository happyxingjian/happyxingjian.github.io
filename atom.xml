<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>高手坟墓</title>
  
  <subtitle>个人技术学习</subtitle>
  <link href="http://happyxingjian.github.io/atom.xml" rel="self"/>
  
  <link href="http://happyxingjian.github.io/"/>
  <updated>2022-10-01T15:48:01.565Z</updated>
  <id>http://happyxingjian.github.io/</id>
  
  <author>
    <name>邢建</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hexo学习</title>
    <link href="http://happyxingjian.github.io/2021/11/04/Hexo%E5%AD%A6%E4%B9%A0/"/>
    <id>http://happyxingjian.github.io/2021/11/04/Hexo%E5%AD%A6%E4%B9%A0/</id>
    <published>2021-11-03T17:14:36.000Z</published>
    <updated>2022-10-01T15:48:01.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hexo操作指南"><a href="#Hexo操作指南" class="headerlink" title="Hexo操作指南"></a>Hexo操作指南</h1><h2 id="Hexo安装"><a href="#Hexo安装" class="headerlink" title="Hexo安装"></a>Hexo安装</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="Hexo初始化"><a href="#Hexo初始化" class="headerlink" title="Hexo初始化"></a>Hexo初始化</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个文件夹，进入并初始化，里面hexo 会自动下载一些文件到这个目录</span></span><br><span class="line"><span class="built_in">cd</span> /d/myblog</span><br><span class="line">hexo init</span><br></pre></td></tr></table></figure><h3 id="初始化后的结构"><a href="#初始化后的结构" class="headerlink" title="初始化后的结构"></a>初始化后的结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：hexo 有 2 个config.yml 文件，一个是站点根目录下的config.yml，一个是 theme（主题）下的_config.yml 文件。</p><h2 id="博客生成、预览"><a href="#博客生成、预览" class="headerlink" title="博客生成、预览"></a>博客生成、预览</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment"># 生成</span></span><br><span class="line">hexo s <span class="comment"># 启动服务</span></span><br></pre></td></tr></table></figure><ul><li>执行以上命令之后，hexo 就会在 public 文件夹生成相关 html 文件，这些就是你博客的静态文件，后续需要把这些提交到 GitHub 上。</li><li>hexo s 是开启本地预览服务，打开浏览器访问 <a href="https://link.zhihu.com/?target=http://localhost:4000/">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故。</li></ul><h2 id="修改主题"><a href="#修改主题" class="headerlink" title="修改主题"></a>修改主题</h2><p>首先下载 hexo-theme-yilia 这个主题：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /d/document/GitHub/hexo/</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia</span><br></pre></td></tr></table></figure><p>下载的主题文件都在 theme 目录下。</p><p>然后我们将 Hexo 根目录下的_config.yml 中的 theme: landscape 改为 theme: yilia，然后重新执行 hexo g 来重新生成。</p><p>注意：如果出现一些莫名其妙的问题，可以先执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br></pre></td></tr></table></figure><p>来清理一下 public 的内容，然后再重新生成。</p><h2 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h2><p>如果你一切都配置好了，接下来就是把博客部署到 GitHub 上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>ssh key 配置好(<strong>如果是https方式可以不配</strong>)。</li><li>配置_config.yml 中有关 deploy 的部分（注意缩进）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:dta0502/dta0502.github.io.git # 用https或者ssh均可</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>直接执行 hexo d 的话一般会报如下错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deployer not found: git</span><br></pre></td></tr></table></figure><p>这是因为缺少了一个插件，我们可以通过如下命令安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后输入 hexo d 就会将本次有改动的代码全部提交。</p><h1 id="常用的-hexo-命令"><a href="#常用的-hexo-命令" class="headerlink" title="常用的 hexo 命令"></a>常用的 hexo 命令</h1><h2 id="收集一"><a href="#收集一" class="headerlink" title="收集一"></a>收集一</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;postName&quot;</span>      <span class="comment"># 新建文章</span></span><br><span class="line">hexo new page <span class="string">&quot;pageName&quot;</span> <span class="comment"># 新建页面</span></span><br><span class="line">hexo generate            <span class="comment"># 生成静态页面至public目录</span></span><br><span class="line">hexo server              <span class="comment"># 开启预览访问端口（默认端口4000，&#x27;ctrl + c&#x27;关闭server）</span></span><br><span class="line">hexo deploy              <span class="comment"># 部署到GitHub</span></span><br><span class="line">hexo <span class="built_in">help</span>                <span class="comment"># 查看帮助</span></span><br><span class="line">hexo version             <span class="comment"># 查看Hexo的版本</span></span><br><span class="line">缩写命令：</span><br><span class="line">hexo n == hexo new</span><br><span class="line">hexo g == hexo generate</span><br><span class="line">hexo s == hexo server</span><br><span class="line">hexo d == hexo deploy</span><br><span class="line">组合命令：</span><br><span class="line">hexo s -g   <span class="comment"># 生成并本地预览</span></span><br><span class="line">hexo d -g   <span class="comment"># 生成并上传</span></span><br></pre></td></tr></table></figure><h2 id="收集二"><a href="#收集二" class="headerlink" title="收集二"></a>收集二</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo -g <span class="comment">#安装Hexo</span></span><br><span class="line">npm update hexo -g <span class="comment">#升级</span></span><br><span class="line">hexo init <span class="comment">#初始化博客</span></span><br><span class="line"></span><br><span class="line">命令简写</span><br><span class="line">hexo n <span class="string">&quot;我的博客&quot;</span> == hexo new <span class="string">&quot;我的博客&quot;</span> <span class="comment">#新建文章</span></span><br><span class="line">hexo g == hexo generate <span class="comment">#生成</span></span><br><span class="line">hexo s == hexo server <span class="comment">#启动服务预览</span></span><br><span class="line">hexo d == hexo deploy <span class="comment">#部署</span></span><br><span class="line"></span><br><span class="line">hexo server <span class="comment">#Hexo会监视文件变动并自动更新，无须重启服务器</span></span><br><span class="line">hexo server -s <span class="comment">#静态模式</span></span><br><span class="line">hexo server -p 5000 <span class="comment">#更改端口</span></span><br><span class="line">hexo server -i 192.168.1.1 <span class="comment">#自定义 IP</span></span><br><span class="line">hexo clean <span class="comment">#清除缓存，若是网页正常情况下可以忽略这条命令</span></span><br></pre></td></tr></table></figure><h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>我们可以在 hexo 根目录下执行命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&#x27;my-first-blog&#x27;</span></span><br></pre></td></tr></table></figure><p>hexo 会帮我们在_posts 下生成相关 md 文件，我们只需要打开这个文件就可以开始写博客了，用这个命令的好处是帮我们<strong>自动生成了文章创建时间</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hexo操作指南&quot;&gt;&lt;a href=&quot;#Hexo操作指南&quot; class=&quot;headerlink&quot; title=&quot;Hexo操作指南&quot;&gt;&lt;/a&gt;Hexo操作指南&lt;/h1&gt;&lt;h2 id=&quot;Hexo安装&quot;&gt;&lt;a href=&quot;#Hexo安装&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="博客" scheme="http://happyxingjian.github.io/categories/%E5%8D%9A%E5%AE%A2/"/>
    
    
    <category term="博客" scheme="http://happyxingjian.github.io/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>JUC笔记</title>
    <link href="http://happyxingjian.github.io/2021/11/04/JUC%E7%AC%94%E8%AE%B0/"/>
    <id>http://happyxingjian.github.io/2021/11/04/JUC%E7%AC%94%E8%AE%B0/</id>
    <published>2021-11-03T17:14:36.000Z</published>
    <updated>2022-10-01T15:51:50.479Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-JUC-简介"><a href="#Java-JUC-简介" class="headerlink" title="Java JUC 简介"></a>Java JUC 简介</h1><blockquote><p>5.0提供的 java.util.concurrent 包，在此包中增加了在并发编程中很常用的实用工具类，用于定义类似于线程的自定义子系统，包括线程池，异步IO,和轻量级任务框架。提供可调的、灵活的线程池。还提供了设计用于多线程上下文中Collection实现等。</p></blockquote><h1 id="volatile关键字（内存可见性）"><a href="#volatile关键字（内存可见性）" class="headerlink" title="volatile关键字（内存可见性）"></a>volatile关键字（内存可见性）</h1><p>内存可见性问题：当多个线程操作共享数据时，彼此不可见。</p><p>volatile关键字：当多个线程操作共享数据时，可以保证内存中数据可见。相较于sychronized是一种轻量级的同步策略</p><p>注意：<br>1、volatile不具备“<strong>互斥性</strong>”<br>2、volatile不能保证变量的“<strong>原子性</strong>”</p><h1 id="原子变量（CAS算法）"><a href="#原子变量（CAS算法）" class="headerlink" title="原子变量（CAS算法）"></a>原子变量（CAS算法）</h1><p>原子变量：jdk1.5后java.util.concurrent.atomic包下提供常用的原子变量。比如AtomicInteger</p><p>该包下的类的特性:</p><ul><li>类的变量都是volatile修饰，保证内存可见性。</li><li>使用CAS(Compare-And-Swap)算法保证数据的原子性。<ul><li>CAS是硬件对于并发操作共享数据的支持</li><li>CAS包含了3个操作数：内存值V，预估值A,更新值B，当且仅当V==A,V=B,否则不做任何操作。</li></ul></li></ul><h1 id="ConcurrentHashMap（锁分段机制）"><a href="#ConcurrentHashMap（锁分段机制）" class="headerlink" title="ConcurrentHashMap（锁分段机制）"></a>ConcurrentHashMap（锁分段机制）</h1><p>对于多线程操作，介于HashMap与Hashtable之间，内部采用“<strong>锁分段</strong>”机制，代替Hashtable的“独占锁”，进而提高性能。</p><p>默认分为16段Segment。</p><h1 id="CountDownLatch（闭锁）"><a href="#CountDownLatch（闭锁）" class="headerlink" title="CountDownLatch（闭锁）"></a>CountDownLatch（闭锁）</h1><p>它是一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或者多个线程一直等待。</p><ul><li>闭锁可以延迟线程的进度直到其到达最终状态。闭锁可以确保某些活动直到其他活动都完成才继续执行。</li><li>确保某个计算在其需要的所有资源都被初始化之后才继续执行。</li><li>确保某个服务在其所依赖的所有服务都已经启动之后才启动</li><li>等待某个操作所有参与者都就绪再继续执行。</li></ul><h1 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h1><p>一、实现Callable接口相较于实现Runable接口的方式：</p><ul><li>可以有返回值</li><li>可以抛出异常</li></ul><p>二、执行Callable方式，需要FutureTask 实现类的支持，用于接收运算后结果。FutureTask是Future接口的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 启动线程方式</span></span><br><span class="line">ThreadDemo td = <span class="keyword">new</span> ThreadDemo();</span><br><span class="line">FutureTask&lt;Integer&gt; result = <span class="keyword">new</span> FutureTask&lt;&gt;(td);</span><br><span class="line"><span class="keyword">new</span> Thread(result).start();</span><br><span class="line">result.get()<span class="comment">//获取线程运算后结果，它会一直等到上述线程执行完毕后才执行get,所以也能实现闭锁。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现Calllable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Lock（同步锁）"><a href="#Lock（同步锁）" class="headerlink" title="Lock（同步锁）"></a>Lock（同步锁）</h1><p>用于解决多线程安全问题的方式</p><ul><li>sychronized:隐式锁<ul><li>同步代码块</li><li>同步方法</li></ul></li><li> 同步锁Lock（jdk1.5以后）：显示锁   通过lock()方法上锁，通过unlock()方法释放锁</li></ul><h1 id="Condition控制线程通信"><a href="#Condition控制线程通信" class="headerlink" title="Condition控制线程通信"></a>Condition控制线程通信</h1><ul><li>Condition接口描述了可能会与锁有关联的条件变量。这些变量在用法上与使用Object.wait()访问的隐式监视器类似，但提供了更强大的功能。需要特别指出的是，<strong>单个Lock可能与多个Condition对象关联</strong>。为了避免兼容问题，Condition中的方法名称与对应的Object版本中不同</li><li>在Condition对象中，与wait、notify、notifyAll对应的分别是<strong>await、signal、signalAll</strong>。</li><li>Condition实例实质上被绑定到一个锁上。要为特定Lock获得Condition实例，请使用其newCondition()方法。</li></ul><h1 id="ReadWriteLock（读写锁）"><a href="#ReadWriteLock（读写锁）" class="headerlink" title="ReadWriteLock（读写锁）"></a>ReadWriteLock（读写锁）</h1><ul><li>写写/读写 需要“互斥”</li><li>读读  不需要“互斥”</li></ul><h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><p>线程池：提供了一个线程队列，队列中保存着所有等待状态的线程。避免了创建销毁的额外开销，提高了响应速度。</p><p>线程池体系结构：</p><ul><li>java.util.concurrent.Executor 接口: 负责线程的使用和调度的<strong>根接口</strong>。<ul><li>ExecutorService 子接口:线程池的主要接口<ul><li><strong>ThreadPoolExecutor</strong> 实现类：</li><li>ScheduledExecutorService 子接口：负责线程的调度<ul><li>ScheduledThreadPoolExecutor实现类:继承了ThreadPoolExecutor，实现ScheduledExecutorService</li></ul></li></ul></li></ul></li></ul><p>工具类：Executors</p><ul><li>ExecutorService newFixedThreadPool():创建固定大小的线程池</li><li>ExecutorService newCachedThreadPool():缓存线程池，线程池的数量不固定，可以根据需求自动地更改数量。</li><li>ExecutorService newSingleThreadExecutor():创建只有一个线程的线程池。</li><li>ScheduledExecutorService newScheduledThreadPool():创建固定大小的线程池，可以延迟或者定时地执行任务。</li></ul><h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><p>定义：提供<strong>线程局部</strong>变量，一个线程局部变量在多个线程中分别有独立的值(<strong>副本</strong>)</p><p>特点：简单(开箱即用)、快速(无额外开销)、安全(线程安全)</p><p>场景：多线程场景（资源持有、线程一致性、并发计算、线程安全等场景）</p><p>实现原理：Java中用<strong>哈希表</strong>实现</p><p>应用范围：几乎所有提供多线程特征的语言</p><p>模型：</p><p><img src="https://gitee.com/gaoshoufengmu/pic/raw/master/java%E6%A0%B8%E5%BF%83/ThreadLocal%E6%A8%A1%E5%9E%8B.jpg" alt="ThreadLocal模型"></p><p>ThreadLocal 常用API</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;T&gt;() <span class="comment">// 构造函数</span></span><br><span class="line">initialValue() <span class="comment">// 初始化</span></span><br><span class="line">get() / set()   <span class="comment">// 访问器</span></span><br><span class="line">remove()   <span class="comment">// 回收</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-JUC-简介&quot;&gt;&lt;a href=&quot;#Java-JUC-简介&quot; class=&quot;headerlink&quot; title=&quot;Java JUC 简介&quot;&gt;&lt;/a&gt;Java JUC 简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;5.0提供的 java.util.conc</summary>
      
    
    
    
    <category term="多线程" scheme="http://happyxingjian.github.io/categories/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
    
    <category term="java" scheme="http://happyxingjian.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Lombok注解</title>
    <link href="http://happyxingjian.github.io/2021/11/04/Lombok%E6%B3%A8%E8%A7%A3/"/>
    <id>http://happyxingjian.github.io/2021/11/04/Lombok%E6%B3%A8%E8%A7%A3/</id>
    <published>2021-11-03T17:14:36.000Z</published>
    <updated>2022-10-01T15:48:00.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是lombok"><a href="#什么是lombok" class="headerlink" title="什么是lombok"></a>什么是lombok</h2><blockquote><p>Lombok项目是一个Java库，它会自动插入编辑器和构建工具中，Lombok提供了一组有用的注释，用来消除Java类中的大量样板代码。仅五个字符(@Data)就可以替换数百行代码从而产生干净，简洁且易于维护的Java类。</p></blockquote><h2 id="使用lombok"><a href="#使用lombok" class="headerlink" title="使用lombok"></a>使用lombok</h2><h3 id="1-引入依赖"><a href="#1-引入依赖" class="headerlink" title="1.引入依赖"></a>1.引入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-使用提供注解"><a href="#2-使用提供注解" class="headerlink" title="2.使用提供注解"></a>2.使用提供注解</h3><h4 id="Data注解："><a href="#Data注解：" class="headerlink" title="@Data注解："></a>@Data注解：</h4><p>用在类上，自动给类提供 SET、 GET、 toString、hashCode、equals等方法</p><h4 id="Getter-Setter"><a href="#Getter-Setter" class="headerlink" title="@Getter/@Setter:"></a>@Getter/@Setter:</h4><p>用在类上，自动给类提供 SET 或者 GET</p><h4 id="ToString"><a href="#ToString" class="headerlink" title="@ToString:"></a>@ToString:</h4><p> 用在类上，自动给类提供 toString()方法</p><h4 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor:"></a>@AllArgsConstructor:</h4><p>用在类上，自动给类提供 全参构造方法,如提供全参，则记得必须加上无参@NoArgsConstructor</p><h4 id="NoArgsConstructor"><a href="#NoArgsConstructor" class="headerlink" title="@NoArgsConstructor:"></a>@NoArgsConstructor:</h4><p>用在类上，自动给类提供 无参构造方法</p><h4 id="Accessors-chain-true-："><a href="#Accessors-chain-true-：" class="headerlink" title="@Accessors(chain = true)："></a>@Accessors(chain = true)：</h4><p>用在类上，用来给类的setter方法开启链式调用,其中chain属性决定是否开启链式<br>    user.set(..).set(..).set()……</p><h4 id="slf4j"><a href="#slf4j" class="headerlink" title="@slf4j:"></a>@slf4j:</h4><p>用在类上,用来快速给类定义一个日志变量</p><p>相当于添加了变量private Logger log = LoggerFactory.getLogger(this.getClass());</p><h2 id="lombok原理"><a href="#lombok原理" class="headerlink" title="lombok原理"></a>lombok原理</h2><p>@Retention(RetentionPolicy.SOURCE),表示在编译成字节码的时候植入代码</p><h2 id="lombok安装"><a href="#lombok安装" class="headerlink" title="lombok安装"></a>lombok安装</h2><p>默认IDEA没有安装lombok插件</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是lombok&quot;&gt;&lt;a href=&quot;#什么是lombok&quot; class=&quot;headerlink&quot; title=&quot;什么是lombok&quot;&gt;&lt;/a&gt;什么是lombok&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Lombok项目是一个Java库，它会自动插入编辑器和构建</summary>
      
    
    
    
    <category term="工具类" scheme="http://happyxingjian.github.io/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
    <category term="java" scheme="http://happyxingjian.github.io/tags/java/"/>
    
  </entry>
  
</feed>
